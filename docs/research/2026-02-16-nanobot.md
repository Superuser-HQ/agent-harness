# Framework Research: nanobot (HKUDS/nanobot)

**Date:** 2026-02-16
**URL:** https://github.com/HKUDS/nanobot
**Language:** Python | **License:** MIT (assumed) | **Stars:** ~15k+

---

## Core Architecture

nanobot is an ultra-lightweight personal AI assistant (~4,000 lines of core code) inspired by OpenClaw. It's positioned as "99% smaller than Clawdbot" while delivering the same core agent functionality.

- **Gateway model:** A central `nanobot gateway` process connects to multiple chat platforms (Telegram, Discord, WhatsApp, Slack, Email, QQ, Feishu, DingTalk, Mochat) and routes messages to agent logic.
- **Config-driven:** Single `~/.nanobot/config.json` controls providers, channels, agents, and tools.
- **Agent loop:** Standard LLM tool-calling loop. The agent receives a message, calls tools as needed, returns a response.
- **Multi-provider:** Supports OpenRouter, Anthropic, OpenAI, DeepSeek, Groq, Gemini, MiniMax, and custom OpenAI-compatible endpoints.

## Tool Model

- Tools are defined in config and loaded at startup.
- MCP support added recently (2026-02-14), allowing external tool servers.
- Built-in tools include web search (Brave), file operations, and code execution.
- "Skills" concept borrowed from OpenClaw — the agent can read skill instructions from URLs and self-configure (e.g., `Read https://moltbook.com/skill.md and follow the instructions`).

## Memory Approach

- Redesigned memory system (2026-02-12): file-based, stored in `~/.nanobot/`.
- Per-conversation context with configurable retention.
- No structured memory tiers — simpler than OpenClaw's daily/long-term split.
- Memory is local-only, not git-backed.

## Multi-Agent Support

- **None natively.** Single-agent architecture.
- "Agent Social Network" feature lets nanobot instances join external platforms (Moltbook, ClawdChat) — more social than collaborative.
- No agent-to-agent RPC, task handoff, or shared state primitives.

## What We'd Steal

| Feature | Relevance to Agent Harness |
|---------|---------------------------|
| **Channel gateway pattern** | The `nanobot gateway` multiplexing across 9+ chat platforms is exactly our messaging surface abstraction (PRD §6). Clean model to study. |
| **Self-configuring via skill URLs** | Agent reads a URL, follows instructions, configures itself. Elegant zero-setup pattern for skill discovery. Could inspire our extension hot-reload. |
| **Config-driven simplicity** | Single JSON config for everything. Our harness should be at least this easy to bootstrap. |
| **Provider abstraction** | Two-step process to add new providers. Good DX target for our LLM abstraction layer. |

## What We'd Avoid

- No multi-agent primitives — doesn't solve our core need (PRD §5).
- Memory system is too simple for compound engineering (no git backing, no structured tiers).
- Python-only — we're TypeScript/Node.js.
- Monolithic design (everything in one process) won't scale to our session tree model.
