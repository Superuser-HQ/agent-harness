# Framework Research: Pi/mom (badlogic/pi-mono)

**Date:** 2026-02-16
**URL:** https://github.com/badlogic/pi-mono
**Language:** TypeScript/Node.js | **License:** MIT | **Stars:** ~12.6k

---

## Core Architecture

Pi-mono is a monorepo containing an AI agent toolkit. The key packages are:

- **`pi-ai`:** Unified multi-provider LLM API (OpenAI, Anthropic, Google, etc.)
- **`pi-agent-core`:** Stateful agent runtime with tool execution and event streaming
- **`pi-coding-agent`:** Interactive coding agent CLI (terminal-first)
- **`pi-mom`:** Slack bot that delegates to the coding agent
- **`pi-tui`:** Terminal UI library with differential rendering
- **`pi-web-ui`:** Web components for AI chat interfaces
- **`pi-pods`:** vLLM deployment management

### pi-agent-core (the engine)

- **Event-driven architecture:** Agent emits granular events (`agent_start`, `turn_start`, `message_update`, `tool_execution_start`, etc.) — excellent for building UIs.
- **Message flow pipeline:** `AgentMessage[] → transformContext() → convertToLlm() → LLM` — clean separation between app messages and LLM messages.
- **Custom message types:** Declaration merging lets you add app-specific message roles (e.g., `notification`). Only standard roles go to the LLM.
- **Steering & follow-up:** Interrupt running agents with steering messages (skips remaining tools), queue follow-up work after completion.
- **State management:** Full `AgentState` with system prompt, model, tools, messages, streaming state — mutable at runtime.
- **Session support:** `sessionId` for provider-level caching, `getApiKey` for dynamic token refresh.
- **Thinking levels:** Configurable thinking (`off` through `xhigh`) with per-provider token budgets.

### pi-mom (the Slack bot)

- **Self-managing:** Installs its own tools, writes scripts, configures credentials autonomously.
- **Workspace model:** Single data directory per instance. Per-channel subdirectories with separate context, memory, and tools.
- **5 core tools:** `bash`, `read`, `write`, `edit`, `attach` — almost identical to our PRD's 5 primitives.
- **Docker sandbox:** Recommended execution model. Agent runs on host, tools execute in container.
- **Context management:** `log.jsonl` (full history, source of truth) + `context.jsonl` (what LLM sees). Compaction when context exceeds window.
- **Memory:** `MEMORY.md` files (global + per-channel). Agent maintains these itself.
- **Skills as CLI tools:** Mom creates bash scripts/programs as reusable tools. No plugin framework needed — just files.

## Tool Model

- **TypeBox schemas:** Tools defined with `AgentTool` using `@sinclair/typebox` for parameter validation.
- **Streaming tools:** `onUpdate` callback for progress reporting during execution.
- **Error convention:** Tools throw errors (not return error strings) — clean separation.
- **Five primitives in mom:** bash, read, write, edit, attach. The agent builds everything else itself via bash.

## Memory Approach

- **File-based, workspace-local:**
  - `MEMORY.md` — global and per-channel long-term memory (agent-maintained)
  - `log.jsonl` — full message history (source of truth, grepable)
  - `context.jsonl` — active LLM context (synced from log, compacted when too large)
- **Compaction:** When context exceeds model window, recent messages stay full, older ones get summarized.
- **Infinite history via grep:** Agent can search `log.jsonl` for anything beyond active context.
- **Not git-backed** natively, but workspace is a directory you control.

## Multi-Agent Support

- **Limited.** pi-agent-core is single-agent. No agent-to-agent communication primitives.
- **Mom is one bot per Slack workspace.** Multiple channel contexts but single agent identity.
- **No RPC, no handoff protocol, no shared artifacts.**

## What We'd Steal

| Feature | Relevance to Agent Harness |
|---------|---------------------------|
| **Event streaming architecture** | pi-agent-core's granular event model (`agent_start` → `turn_start` → `message_update` → `tool_execution_*` → `turn_end` → `agent_end`) is exactly what we need for UI, logging, and inter-agent coordination. |
| **Message pipeline (transformContext → convertToLlm)** | Clean separation of app-level messages from LLM messages. Custom message types via declaration merging is elegant. Direct port candidate. |
| **Steering & follow-up queues** | Ability to interrupt running agents and queue follow-up work. Critical for our session tree model where branches need coordination. |
| **5 core tools pattern** | `bash`, `read`, `write`, `edit`, `attach` maps almost 1:1 to our PRD primitives (`Read`, `Write`, `Edit`, `Shell`, `Message`). Validates our design. |
| **Self-managing workspace** | Mom's "install your own tools, configure your own credentials" philosophy is compound engineering in action. Our harness should enable this. |
| **Context compaction** | Summarize-and-compact when context exceeds window. Essential for long-running sessions. |
| **TypeScript/Node.js** | Same runtime as our target. Could potentially wrap pi-agent-core directly (this is the "critical fork" in PRD §10). |
| **Workspace directory model** | `log.jsonl` + `context.jsonl` + `MEMORY.md` + `skills/` is a proven structure. Extend with git backing for our needs. |
| **Dynamic model/tool swapping** | `setModel()`, `setTools()`, `setThinkingLevel()` at runtime. Hot-swap without restart. |

## What We'd Avoid

- **Terminal-first, messaging-second.** Mom is a Slack bot bolted onto a coding agent. We need messaging-first (PRD §6).
- **No multi-agent primitives.** This is the biggest gap. We'd need to build RPC, handoff, and coordination on top.
- **Single-provider memory.** MEMORY.md is hand-maintained by the agent. No structured memory tiers, no automatic compound capture.
- **Monorepo coupling.** Packages are tightly coupled (pi-mom depends on pi-agent-core depends on pi-ai). Extracting just the agent core may pull in more than wanted.

## Critical Fork Assessment

The PRD's key architectural decision: **build own agent loop vs. wrap pi-agent-core?**

**For wrapping:**
- Session state, event streaming, tool execution, context management — all solved.
- TypeScript, MIT licensed, same primitives we'd build anyway.
- Saves 2-3 weeks of core loop development.

**Against wrapping:**
- Terminal-first assumptions may fight our messaging-first design.
- No session trees (flat history only).
- No multi-agent awareness in the core.
- Dependency on Mario Zechner's maintenance priorities.
- Monorepo structure means tracking upstream is harder than a single package.

**Recommendation:** Use pi-agent-core's *design patterns* (event model, message pipeline, steering) but build our own implementation. The patterns are more valuable than the code. If we wrap, we'll spend as much time fighting the abstraction as we'd spend building our own.
